<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>æ—¥æœ¬è¦³å…‰æ¤œç´¢ã‚¢ãƒ—ãƒª</title>

  <style>
    #map {
      height: 400px;
      width: 100%;
      margin-top: 20px;
      border: 2px solid #ccc;
      border-radius: 10px;
    }
  </style>

  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gradient-to-r from-blue-100 via-pink-100 to-yellow-100 min-h-screen flex items-center justify-center">

  <div id="app" class="w-full max-w-4xl p-8 bg-white/90 backdrop-blur rounded-2xl shadow-2xl">
    <!-- ãƒ˜ãƒƒãƒ€ãƒ¼ -->
    <div class="text-center mb-6">
      <h1 class="text-3xl font-bold text-blue-700 mb-2">ğŸŒ¸ æ—¥æœ¬è¦³å…‰æ¤œç´¢ã‚¢ãƒ—ãƒª ğŸŒ¸</h1>
      <p class="text-gray-600">åœ°åã‚’å…¥åŠ›ã™ã‚‹ã¨è¦³å…‰åœ°ãƒ»é£Ÿã¹ç‰©ãƒ»ãƒ›ãƒ†ãƒ«ã‚’ãŠã™ã™ã‚ã—ã¾ã™ï¼ˆæ—¥æœ¬å›½å†…é™å®šï¼‰</p>
    </div>

    <!-- å…¥åŠ›ãƒ•ã‚©ãƒ¼ãƒ ï¼ˆEnterã§å®Ÿè¡Œï¼‰ -->
    <form class="flex gap-2 mb-6" @submit.prevent="search">
      <input v-model="query"
             type="text"
             placeholder="ä¾‹: äº¬éƒ½, æ±äº¬, æœ­å¹Œ..."
             class="flex-1 border-2 border-gray-300 rounded-xl p-3 focus:ring-2 focus:ring-blue-400 outline-none">
      <button type="submit"
              class="bg-gradient-to-r from-blue-500 to-indigo-500 text-white px-6 py-3 rounded-xl shadow-md hover:scale-105 transition-transform">
        æ¤œç´¢
      </button>
    </form>

    <!-- ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚° -->
    <div v-if="loading" class="text-center text-gray-500 animate-pulse">æ¤œç´¢ä¸­ã§ã™...âœ¨</div>

    <!-- ã‚¨ãƒ©ãƒ¼ -->
    <div v-if="error" class="text-center text-red-500 font-semibold">{{ error }}</div>

    <!-- çµæœè¡¨ç¤ºï¼ˆã‚«ãƒ¼ãƒ‰UIï¼‰ -->
    <div v-if="cards" class="mt-6">
      <h2 class="text-xl font-semibold mb-4 text-indigo-600">ğŸ“ æ¤œç´¢çµæœ</h2>

      <!-- ç”»åƒ -->
      <div v-if="image" class="mb-6">
        <img :src="image" alt="è¦³å…‰åœ°ã®å†™çœŸ" class="rounded-lg shadow-md w-full object-cover max-h-80">
      </div>

      <!-- ã‚«ãƒ¼ãƒ‰UI -->
      <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
        <div v-for="(list, key) in cards.sections" :key="key"
             class="rounded-2xl border bg-white shadow-sm p-4">
          <div class="flex items-center gap-2 mb-2">
            <span v-if="key==='è¦³å…‰åœ°'">ğŸ—ºï¸</span>
            <span v-else-if="key==='åç‰©ã‚°ãƒ«ãƒ¡'">ğŸ½ï¸</span>
            <span v-else>ğŸ¨</span>
            <h3 class="font-semibold text-gray-800">{{ key }}</h3>
          </div>
          <ul class="space-y-2">
            <li v-for="it in list" :key="it.name" class="text-sm leading-6">
              <div class="font-semibold">
                <!-- ãƒ›ãƒ†ãƒ«ã¯ URL ãŒã‚ã‚Œã°ãƒªãƒ³ã‚¯åŒ– -->
                <template v-if="key==='ãŠã™ã™ã‚ãƒ›ãƒ†ãƒ«' && it.url">
                  <a :href="it.url" target="_blank" rel="noopener" class="text-blue-600 hover:underline">
                    {{ it.name }}
                  </a>
                </template>
                <template v-else>
                  <span class="text-gray-900">{{ it.name }}</span>
                </template>
              </div>
              <div class="text-gray-600">{{ it.desc }}</div>
            </li>
          </ul>
        </div>
      </div>

      <!-- ãƒ¢ãƒ‡ãƒ«ãƒ«ãƒ¼ãƒˆ -->
      <div v-if="cards.route" class="rounded-xl border p-4 bg-amber-50 border-amber-200 mb-4">
        <div class="font-semibold mb-1">ğŸ§­ ãƒ¢ãƒ‡ãƒ«ãƒ«ãƒ¼ãƒˆ</div>
        <div class="text-sm whitespace-pre-wrap">{{ cards.route }}</div>
      </div>
    </div>

    <!-- â˜… åœ°å›³ã¯å¸¸è¨­ï¼ˆDOMã‹ã‚‰æ¶ˆã•ãªã„ï¼‰ã€‚è¡¨ç¤º/éè¡¨ç¤ºã ã‘ v-show ã§åˆ¶å¾¡ -->
    <div id="map" v-show="cards"></div>
  </div>

  <script>
    const { createApp, nextTick } = Vue;

    createApp({
      data() {
        return {
          query: "",
          image: null,
          loading: false,
          error: null,
          cards: null,
          map: null,
          marker: null,
          mapsLoaded: false
        };
      },

      methods: {
        /* ===== Google Maps ã‚’ /config ã‹ã‚‰èª­ã¿è¾¼ã¿ ===== */
        async loadGoogleMaps() {
          try {
            const res = await fetch("/config");
            const cfg = await res.json();
            const key = (cfg && cfg.GOOGLE_MAPS_JS_KEY) || "";
            if (!key) {
              this.error = "Google Mapsã®APIã‚­ãƒ¼ãŒæœªè¨­å®šã§ã™ï¼ˆ/config ãŒç©ºï¼‰ã€‚.env ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚";
              console.error("Missing GOOGLE_MAPS_JS_KEY from /config");
              return;
            }

            const url = `https://maps.googleapis.com/maps/api/js?key=${encodeURIComponent(key)}`;
            await new Promise((resolve, reject) => {
              const s = document.createElement("script");
              s.src = url;
              s.async = true;
              s.onload = () => { this.mapsLoaded = true; resolve(); };
              s.onerror = (e) => { this.error = "Google Mapsã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚"; reject(e); };
              document.head.appendChild(s);
            });

            if (!window.google || !google.maps) {
              this.error = "Google Mapsã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸï¼ˆConsoleã‚’ç¢ºèªï¼‰ã€‚";
              console.error("[Maps] google.maps is undefined");
              return;
            }
          } catch (e) {
            console.error("loadGoogleMaps failed:", e);
            if (!this.error) this.error = "Google Mapsã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚";
          }
        },

        /* ===== ç”Ÿãƒ†ã‚­ã‚¹ãƒˆã‚’ãƒ‘ãƒ¼ã‚¹ã—ã¦ sections + route ã«å¤‰æ› =====
           è¦³å…‰åœ°ãƒ»åç‰©ã‚°ãƒ«ãƒ¡: ã€Œåå‰ - èª¬æ˜ã€
           ãŠã™ã™ã‚ãƒ›ãƒ†ãƒ«   : ã€Œãƒ›ãƒ†ãƒ«å - èª¬æ˜ - å…¬å¼URLã€
        */
        parseSections(raw) {
          const sections = { "è¦³å…‰åœ°": [], "åç‰©ã‚°ãƒ«ãƒ¡": [], "ãŠã™ã™ã‚ãƒ›ãƒ†ãƒ«": [] };
          let current = null;
          let route = "";

          (raw || "").split("\n").forEach(line => {
            line = line.trim();
            if (/^è¦³å…‰åœ°\s*$/.test(line))         { current = "è¦³å…‰åœ°"; return; }
            if (/^åç‰©ã‚°ãƒ«ãƒ¡\s*$/.test(line))     { current = "åç‰©ã‚°ãƒ«ãƒ¡"; return; }
            if (/^ãŠã™ã™ã‚ãƒ›ãƒ†ãƒ«\s*$/.test(line)) { current = "ãŠã™ã™ã‚ãƒ›ãƒ†ãƒ«"; return; }

            // ãƒ›ãƒ†ãƒ«ã¯ URL ä»˜ãã«å¯¾å¿œï¼ˆãƒ›ãƒ†ãƒ«å - èª¬æ˜ - URLï¼‰
            if (current === "ãŠã™ã™ã‚ãƒ›ãƒ†ãƒ«") {
              const m3 = line.match(/^(.+?)\s*-\s*(.+?)\s*-\s*(https?:\/\/\S+)/);
              if (m3) {
                sections[current].push({ name: m3[1], desc: m3[2], url: m3[3] });
                return;
              }
            }

            // é€šå¸¸ã®é …ç›®ï¼ˆåå‰ - èª¬æ˜ï¼‰
            const m2 = line.match(/^(.+?)\s*-\s*(.+)$/);
            if (m2 && current) {
              sections[current].push({ name: m2[1], desc: m2[2] });
            }

            // ãƒ¢ãƒ‡ãƒ«ãƒ«ãƒ¼ãƒˆï¼ˆnæ—¥ç›®ï¼šã€œï¼‰
            if (/^\d+æ—¥ç›®ï¼š/.test(line)) {
              route += line + "\n";
            }
          });

          return { sections, route: route.trim() };
        },

        /* ===== æ¤œç´¢å‡¦ç† ===== */
        async search() {
          if (!this.query) {
            this.error = "åœ°åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„";
            return;
          }
          this.loading = true;
          this.error = null;
          this.cards = null;

          try {
            const res = await fetch("/search", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ query: this.query })
            });
            const data = await res.json();

            if (!res.ok) {
              this.error = data?.message || data?.error || `ã‚µãƒ¼ãƒãƒ¼ã‚¨ãƒ©ãƒ¼ (${res.status})`;
              return;
            }
            if (data.error) {
              this.error = data.error;
              return;
            }

            this.image = data.image;
            this.cards = this.parseSections(data.result);

            // DOMã¸ã‚«ãƒ¼ãƒ‰ãƒ»åœ°å›³æ ã®åæ˜ ã‚’å¾…ã£ã¦ã‹ã‚‰åœ°å›³æ›´æ–°
            await nextTick();
            await this.showMap(this.query);
          } catch (err) {
            this.error = "ã‚µãƒ¼ãƒãƒ¼ã‚¨ãƒ©ãƒ¼: " + err;
          } finally {
            this.loading = false;
          }
        },

        /* ===== åœ°å›³è¡¨ç¤ºï¼ˆæ—¥æœ¬å›½å†…ã«åˆ¶ç´„ãƒ»å†æ¤œç´¢ã§ã‚‚å®‰å®šï¼‰ ===== */
        async showMap(address) {
          if (!this.mapsLoaded || !window.google || !google.maps) {
            this.error = "Google Mapsã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚";
            console.error("[Maps] Not loaded or API unavailable");
            return;
          }

          // å¿µã®ãŸã‚ã€DOMã« #map ãŒã‚ã‚‹ã®ã‚’ä¿è¨¼
          await nextTick();
          const mapEl = document.getElementById("map");
          if (!mapEl) {
            console.warn("#map element not found");
            return;
          }

          const geocoder = new google.maps.Geocoder();

          return new Promise((resolve) => {
            geocoder.geocode(
              { address, componentRestrictions: { country: "JP" } },
              (results, status) => {
                if (status !== "OK" || !results?.[0]) {
                  this.error = "åœ°å›³ã‚’è¡¨ç¤ºã§ãã¾ã›ã‚“: " + status;
                  console.error("[Geocode] failed:", status);
                  return resolve(false);
                }

                const loc = results[0].geometry.location;

                // æ—¢å­˜ map ã®ã‚³ãƒ³ãƒ†ãƒŠãŒå·®ã—æ›¿ã‚ã£ã¦ã„ãŸã‚‰å†åˆæœŸåŒ–
                const needsRecreate = !this.map || (this.map.getDiv && this.map.getDiv() !== mapEl);

                if (needsRecreate) {
                  this.map = new google.maps.Map(mapEl, { center: loc, zoom: 13 });
                } else {
                  this.map.setCenter(loc);
                  this.map.setZoom(13);
                }

                // ãƒãƒ¼ã‚«ãƒ¼æ›´æ–°
                if (this.marker) this.marker.setMap(null);
                this.marker = new google.maps.Marker({ map: this.map, position: loc, title: address });

                // è¡¨ç¤ºåˆ‡æ›¿ç›´å¾Œã®å†æç”»
                if (google.maps.event && this.map) {
                  google.maps.event.trigger(this.map, "resize");
                }

                resolve(true);
              }
            );
          });
        }
      },

      async mounted() {
        await this.loadGoogleMaps();
      }
    }).mount("#app");
  </script>
</body>
</html>
